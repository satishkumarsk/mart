# Usermanagement

## Build status [![Build Status](https://travis-ci.com/sathish006/mart.svg?branch=master)](https://travis-ci.com/sathish006/mart/builds)

## Code coverage [![codecov](https://codecov.io/gh/sathish006/mart/branch/master/graph/badge.svg)](https://codecov.io/gh/sathish006/mart)

## CI [pipeline](https://travis-ci.com/sathish006/mart)

## Overview
An example of Usermanagement service implemented using [Connexion](https://github.com/zalando/connexion) library on top of Flask backed by mysql datastore. Stubs are generated by the [swagger-codegen](https://github.com/swagger-api/swagger-codegen) project along with  [OpenAPI-Spec](https://github.com/swagger-api/swagger-core/wiki).

## Features
 * Swagger integration
 * CI integration with Travis for builds [pipeline](https://travis-ci.com/sathish006/mart)
 * APM Montioring integration with Prometheus
 * Single command service and environment up using Docker compose
 * Montioring dashboards built with grafana
 * JWT implementation for login
 * SHA256 - password hasing 
 * CI pipeline for pushing docker images to registry
 * Unit test integration with CI pipeline 
 * Code coverage report with CI pipeline 
 * Prodcution deployemnts using chef [cookbook](https://github.com/sathish006/cookbooks)

## Assumptions
 - Assuming a ubuntu linux workstation 

## Requirements
  * Python 2.7+
  * Docker version needed 17+
 


## Setting local environment
To setup environment, please execute the following from the projects root directory:
```
docker-compose up
```
Check service is up visting 
```
http://localhost:8080/v1/ui/
```

## Login API for ADMIN 

Request body for swagger to be provided
```
{
  "password": "admin",
  "username": "admin"
} 

```
Note:
  Certain API's need user to login . So for login hit swagger with above payload


## Known issue with docker compose / To do
 * Startup order- removed and not guranteed for service up on latest docker compose version so app restart expected intially till DB is up
 * To do - Implemnent healthchecks as part of startup on docker compose file for service ordering 


## APM monitoring prometheus

```
http://localhost:8080/v1/ui/

```

## Metrics published as part of application with per api call and Status code

```
flask_request_latency_seconds Flask Request Latency
flask_request_count
process_max_fds
process_open_fds
```

## Sample metrics
```
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="0.005",method="POST"} 1.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="0.01",method="POST"} 1.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="0.025",method="POST"} 1.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="0.05",method="POST"} 1.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="0.075",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="0.1",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="0.25",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="0.5",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="0.75",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="1.0",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="2.5",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="5.0",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="7.5",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="10.0",method="POST"} 2.0
flask_request_latency_seconds_bucket{endpoint="/v1/login",le="+Inf",method="POST"} 2.0
flask_request_latency_seconds_count{endpoint="/v1/login",method="POST"} 2.0
```

For more metrics per status code 
```
http://localhost:9000/
```

## Prometheus endpoint
```
http://localhost:9090/targets
```

## Grafana dashboards

Note: Sigup as admin and dasboard name usermanagemnt-apm. Generate some request for viewing metrics 

```
http://localhost:3000/
```

## Build pipeline architecture
For prod
```
Code push/PR +-----> Github hooks +-----> Travis CI gets Invoked +-----> Run unit Test +-----> Code coverage (If > Acceptable value) +-----> Docker build(for dev branch) &Create Tag (Only on master build) ----> Push tag to prod via cookbook
```

## TODO/Future imporvements:
 * Integrate CD 
 * Intergrate alert manager for alerting
 * Integrate notifications for CI and CD pipeline
 * Add infra monitoring 
 * Chat ops based deployemnt
 * Enhance docs
  
## General Note:

The tools mentioned are the ones that I have worked with and have proved to work at large scales. These are a lot of other tools that are available and each has to be picked based on the requirement and scale and other factors
